#%%[markdown]

# # Absorption emission auto analysis

# Experimenting with autogenerated plots across a test case dimension and mnum
# Using groupby instead of for loops like mws 1d auto 


#%%

from mhdpy.analysis.standard_import import *
create_standard_folders()
import pi_paper_utils as ppu

figsize = (10, 8)
# plt.rcParams.update({'figure.figsize':(3,3), 'figure.dpi':100})

from mhdpy.analysis.absem.fitting import gen_model_alpha_blurred 
from mhdpy.analysis import absem

from mhdpy.xr_utils import XarrayUtilsAccessorCommon

# %%

# tc = '536_pos'

import argparse

# Create the parser
parser = argparse.ArgumentParser(description='Process some data.')

# Add a positional argument for tc
parser.add_argument('tc', type=str, help='a required tc argument')

# Parse the arguments
args = parser.parse_args()

# Now you can use args.tc as your tc variable
tc = args.tc
# tc = '53x'


tc_dim_dict = {
    '53x': 'kwt',
    '536_pos': 'motor',
    '536_power': 'power'
}

tc_dim = tc_dim_dict[tc]

figure_out_dir = pjoin(DIR_DATA_OUT, 'absem_1d', tc)
if not os.path.exists(figure_out_dir): os.makedirs(figure_out_dir)

ds_absem = ppu.fileio.load_absem(tc)

ds_absem = ds_absem.drop_vars('acq_time')

ds_absem

#%%

plt.figure()

da_counts = ds_absem['led_on'].count('mnum').isel(wavelength=0)
da_counts.name = 'counts'

da_counts.plot(hue='mp', row='run', marker='o', figsize=figsize)

plt.savefig(pjoin(figure_out_dir, '{}_counts.png'.format(tc) ))



#%%


if tc_dim == 'kwt':
    ds_sel = ds_absem.sel(mp='barrel')
else:
    ds_sel = ds_absem.sel(mp='mw_horns')
    ds_sel = ds_sel.dropna('mnum', how='all')
    ds_sel = ds_sel.dropna('run', how='all')
# ds_sel = ds_sel.sel(run=[('2023-05-24', 1)]).dropna('mnum', how='all').dropna('kwt', how='all')

#%%

def groupby_run_processor(ds_plot, max_mnum=5):
    #TODO: assert that there is only one run coord, which should be true as we are grouping by it
    run_name = ds_plot.coords['run'].item()
    run_name = "{}_{}".format(run_name[0], run_name[1])

    ds_plot = ds_plot.groupby(tc_dim).apply(lambda x: x.xr_utils.assign_mnum('mnum'))

    # Warning, this is the number of columns
    ds_plot = ds_plot.isel(mnum=range(max_mnum))

    return ds_plot, run_name

def plot_alpha(ds_plot, run_name, ylim=(-1.1, 1.5), xlim=(765, 772)):

    da_plot = ds_plot['alpha']
    da_plot = da_plot.dropna(tc_dim, how='all')
    da_plot.plot(hue='mnum', row=tc_dim, figsize=figsize)
    plt.ylim(ylim)
    plt.xlim(xlim)

    # add horizontal line at 0 
    plt.axhline(0, color='k', linestyle='--', linewidth=0.5)

    fp_out = pjoin(figure_out_dir, "{}_alpha_{}.png".format(run_name, tc))
    plt.savefig(fp_out)

    return ds_plot

ds_sel.groupby('run').apply(lambda ds: plot_alpha(*groupby_run_processor(ds)))


#%%

def plot_led1(ds_plot, run_name):

    da = ds_plot[['led_on','led_off','diff','calib']].to_array('var')

    da = da.dropna(tc_dim, how='all')
    da.plot(hue='var', col='mnum', row=tc_dim, figsize=figsize)

    plt.xlim(765,768)

    fp_out = pjoin(figure_out_dir, "{}_led1_{}.png".format(run_name, tc))
    plt.savefig(fp_out)

    return ds_plot

ds_sel.groupby('run').apply(lambda ds: plot_led1(*groupby_run_processor(ds)))
#%%

def plot_led2(ds_plot, run_name):

    da_plot = ds_plot[['led_on','led_off','diff']].to_array('var')
    da_plot = da_plot.dropna(tc_dim, how='all')
    g = da_plot.plot(hue='mnum', col='var', row=tc_dim, sharey=False, figsize=figsize)

    for i, tc_val in enumerate(da_plot.coords[tc_dim].values):

        calib = ds_plot['calib'].sel({tc_dim : tc_val}).mean('mnum')

        ax = g.axs[i, -1]
        calib.plot(ax=ax, color='black', linestyle='--')

        ax.set_title('')

        ax.axhline(0, color='k', linestyle='--', linewidth=0.5)


    fp_out = pjoin(figure_out_dir, "{}_led2_{}.png".format(run_name, tc))
    plt.savefig(fp_out)

    return ds_plot


ds_sel.groupby('run').apply(lambda ds: plot_led2(*groupby_run_processor(ds)))

